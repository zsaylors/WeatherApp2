/**
 * @fileoverview added by tsickle
 * Generated from: lib/markers-for-clusters/markers-for-clusters.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, Input, NgZone, TemplateRef } from '@angular/core';
import { fromEvent, merge, Subscription } from 'rxjs';
import { filter, startWith, switchMap } from 'rxjs/operators';
import { MapService } from '../map/map.service';
export class PointDirective {
}
PointDirective.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[mglPoint]' },] }
];
export class ClusterPointDirective {
}
ClusterPointDirective.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[mglClusterPoint]' },] }
];
/** @type {?} */
let uniqId = 0;
export class MarkersForClustersComponent {
    /**
     * @param {?} MapService
     * @param {?} ChangeDetectorRef
     * @param {?} zone
     */
    constructor(MapService, ChangeDetectorRef, zone) {
        this.MapService = MapService;
        this.ChangeDetectorRef = ChangeDetectorRef;
        this.zone = zone;
        // Incorrect typings
        this.layerId = `mgl-markers-for-clusters-${uniqId++}`;
        this.sub = new Subscription();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const clusterDataUpdate = (/**
         * @return {?}
         */
        () => fromEvent((/** @type {?} */ (this.MapService.mapInstance)), 'data').pipe(filter((/**
         * @param {?} e
         * @return {?}
         */
        (e) => e.sourceId === this.source &&
            e.sourceDataType !== 'metadata' &&
            this.MapService.mapInstance.isSourceLoaded(this.source)))));
        /** @type {?} */
        const sub = this.MapService.mapCreated$
            .pipe(switchMap(clusterDataUpdate), switchMap((/**
         * @return {?}
         */
        () => merge(fromEvent((/** @type {?} */ (this.MapService.mapInstance)), 'move'), fromEvent((/** @type {?} */ (this.MapService.mapInstance)), 'moveend')).pipe(startWith(undefined)))))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.zone.run((/**
             * @return {?}
             */
            () => {
                this.updateCluster();
            }));
        }));
        this.sub.add(sub);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    /**
     * @param {?} _index
     * @param {?} clusterPoint
     * @return {?}
     */
    trackByClusterPoint(_index, clusterPoint) {
        return clusterPoint.id;
    }
    /**
     * @private
     * @return {?}
     */
    updateCluster() {
        // Invalid queryRenderedFeatures typing
        /** @type {?} */
        const params = { layers: [this.layerId] };
        if (!this.pointTpl) {
            params.filter = ['==', 'cluster', true];
        }
        this.clusterPoints = this.MapService.mapInstance.queryRenderedFeatures(params);
        this.ChangeDetectorRef.markForCheck();
    }
}
MarkersForClustersComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-markers-for-clusters',
                template: `
    <mgl-layer [id]="layerId" [source]="source" type="circle" [paint]="{ 'circle-radius': 0 }"></mgl-layer>
    <ng-container *ngFor="let feature of clusterPoints; trackBy: trackByClusterPoint">
      <ng-container *ngIf="feature.properties.cluster">
        <mgl-marker [feature]="feature">
          <ng-container *ngTemplateOutlet="clusterPointTpl; context: { $implicit: feature }"></ng-container>
        </mgl-marker>
      </ng-container>
      <ng-container *ngIf="!feature.properties.cluster">
        <mgl-marker [feature]="feature">
          <ng-container *ngTemplateOutlet="pointTpl; context: { $implicit: feature }"></ng-container>
        </mgl-marker>
      </ng-container>
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            }] }
];
/** @nocollapse */
MarkersForClustersComponent.ctorParameters = () => [
    { type: MapService },
    { type: ChangeDetectorRef },
    { type: NgZone }
];
MarkersForClustersComponent.propDecorators = {
    source: [{ type: Input }],
    pointTpl: [{ type: ContentChild, args: [PointDirective, { read: TemplateRef, static: false },] }],
    clusterPointTpl: [{ type: ContentChild, args: [ClusterPointDirective, { read: TemplateRef, static: false },] }]
};
if (false) {
    /** @type {?} */
    MarkersForClustersComponent.prototype.source;
    /** @type {?} */
    MarkersForClustersComponent.prototype.pointTpl;
    /** @type {?} */
    MarkersForClustersComponent.prototype.clusterPointTpl;
    /** @type {?} */
    MarkersForClustersComponent.prototype.clusterPoints;
    /** @type {?} */
    MarkersForClustersComponent.prototype.layerId;
    /**
     * @type {?}
     * @private
     */
    MarkersForClustersComponent.prototype.sub;
    /**
     * @type {?}
     * @private
     */
    MarkersForClustersComponent.prototype.MapService;
    /**
     * @type {?}
     * @private
     */
    MarkersForClustersComponent.prototype.ChangeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    MarkersForClustersComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya2Vycy1mb3ItY2x1c3RlcnMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LW1hcGJveC1nbC8iLCJzb3VyY2VzIjpbImxpYi9tYXJrZXJzLWZvci1jbHVzdGVycy9tYXJrZXJzLWZvci1jbHVzdGVycy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBRUwsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsWUFBWSxFQUNaLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUVOLFdBQVcsRUFDWixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBR2hELE1BQU0sT0FBTyxjQUFjOzs7WUFEMUIsU0FBUyxTQUFDLEVBQUUsUUFBUSxFQUFFLHVCQUF1QixFQUFFOztBQUloRCxNQUFNLE9BQU8scUJBQXFCOzs7WUFEakMsU0FBUyxTQUFDLEVBQUUsUUFBUSxFQUFFLDhCQUE4QixFQUFFOzs7SUFHbkQsTUFBTSxHQUFHLENBQUM7QUFzQmQsTUFBTSxPQUFPLDJCQUEyQjs7Ozs7O0lBWXRDLFlBQW9CLFVBQXNCLEVBQVUsaUJBQW9DLEVBQVUsSUFBWTtRQUExRixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQVUsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUFVLFNBQUksR0FBSixJQUFJLENBQVE7O1FBSjlHLFlBQU8sR0FBRyw0QkFBNEIsTUFBTSxFQUFFLEVBQUUsQ0FBQztRQUV6QyxRQUFHLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztJQUVnRixDQUFDOzs7O0lBRWxILGtCQUFrQjs7Y0FDVixpQkFB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ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgRGlyZWN0aXZlLFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWFwYm94R2VvSlNPTkZlYXR1cmUsIE1hcFNvdXJjZURhdGFFdmVudCB9IGZyb20gJ21hcGJveC1nbCc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwL21hcC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnbmctdGVtcGxhdGVbbWdsUG9pbnRdJyB9KVxuZXhwb3J0IGNsYXNzIFBvaW50RGlyZWN0aXZlIHt9XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ25nLXRlbXBsYXRlW21nbENsdXN0ZXJQb2ludF0nIH0pXG5leHBvcnQgY2xhc3MgQ2x1c3RlclBvaW50RGlyZWN0aXZlIHt9XG5cbmxldCB1bmlxSWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtZ2wtbWFya2Vycy1mb3ItY2x1c3RlcnMnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxtZ2wtbGF5ZXIgW2lkXT1cImxheWVySWRcIiBbc291cmNlXT1cInNvdXJjZVwiIHR5cGU9XCJjaXJjbGVcIiBbcGFpbnRdPVwieyAnY2lyY2xlLXJhZGl1cyc6IDAgfVwiPjwvbWdsLWxheWVyPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGZlYXR1cmUgb2YgY2x1c3RlclBvaW50czsgdHJhY2tCeTogdHJhY2tCeUNsdXN0ZXJQb2ludFwiPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImZlYXR1cmUucHJvcGVydGllcy5jbHVzdGVyXCI+XG4gICAgICAgIDxtZ2wtbWFya2VyIFtmZWF0dXJlXT1cImZlYXR1cmVcIj5cbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY2x1c3RlclBvaW50VHBsOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogZmVhdHVyZSB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbWdsLW1hcmtlcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFmZWF0dXJlLnByb3BlcnRpZXMuY2x1c3RlclwiPlxuICAgICAgICA8bWdsLW1hcmtlciBbZmVhdHVyZV09XCJmZWF0dXJlXCI+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInBvaW50VHBsOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogZmVhdHVyZSB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbWdsLW1hcmtlcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2Vcbn0pXG5leHBvcnQgY2xhc3MgTWFya2Vyc0ZvckNsdXN0ZXJzQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0IHtcbiAgLyogSW5pdCBpbnB1dCAqL1xuICBASW5wdXQoKSBzb3VyY2U6IHN0cmluZztcblxuICBAQ29udGVudENoaWxkKFBvaW50RGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IGZhbHNlIH0pIHBvaW50VHBsPzogVGVtcGxhdGVSZWY8YW55PjtcbiAgQENvbnRlbnRDaGlsZChDbHVzdGVyUG9pbnREaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogZmFsc2UgfSkgY2x1c3RlclBvaW50VHBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNsdXN0ZXJQb2ludHM6IE1hcGJveEdlb0pTT05GZWF0dXJlW107IC8vIEluY29ycmVjdCB0eXBpbmdzXG4gIGxheWVySWQgPSBgbWdsLW1hcmtlcnMtZm9yLWNsdXN0ZXJzLSR7dW5pcUlkKyt9YDtcblxuICBwcml2YXRlIHN1YiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIE1hcFNlcnZpY2U6IE1hcFNlcnZpY2UsIHByaXZhdGUgQ2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLCBwcml2YXRlIHpvbmU6IE5nWm9uZSkge31cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgY29uc3QgY2x1c3RlckRhdGFVcGRhdGUgPSAoKSA9PlxuICAgICAgZnJvbUV2ZW50PE1hcFNvdXJjZURhdGFFdmVudD4oPGFueT50aGlzLk1hcFNlcnZpY2UubWFwSW5zdGFuY2UsICdkYXRhJykucGlwZShcbiAgICAgICAgZmlsdGVyKFxuICAgICAgICAgIChlKSA9PlxuICAgICAgICAgICAgZS5zb3VyY2VJZCA9PT0gdGhpcy5zb3VyY2UgJiZcbiAgICAgICAgICAgIGUuc291cmNlRGF0YVR5cGUgIT09ICdtZXRhZGF0YScgJiZcbiAgICAgICAgICAgIHRoaXMuTWFwU2VydmljZS5tYXBJbnN0YW5jZS5pc1NvdXJjZUxvYWRlZCh0aGlzLnNvdXJjZSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICBjb25zdCBzdWIgPSB0aGlzLk1hcFNlcnZpY2UubWFwQ3JlYXRlZCRcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoY2x1c3RlckRhdGFVcGRhdGUpLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT5cbiAgICAgICAgICBtZXJnZShcbiAgICAgICAgICAgIGZyb21FdmVudCg8YW55PnRoaXMuTWFwU2VydmljZS5tYXBJbnN0YW5jZSwgJ21vdmUnKSxcbiAgICAgICAgICAgIGZyb21FdmVudCg8YW55PnRoaXMuTWFwU2VydmljZS5tYXBJbnN0YW5jZSwgJ21vdmVlbmQnKVxuICAgICAgICAgICkucGlwZShzdGFydFdpdGg8YW55Pih1bmRlZmluZWQpKVxuICAgICAgICApXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDbHVzdGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgdGhpcy5zdWIuYWRkKHN1Yik7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1Yi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgdHJhY2tCeUNsdXN0ZXJQb2ludChfaW5kZXg6IG51bWJlciwgY2x1c3RlclBvaW50OiB7IGlkOiBudW1iZXIgfSkge1xuICAgIHJldHVybiBjbHVzdGVyUG9pbnQuaWQ7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUNsdXN0ZXIoKSB7XG4gICAgLy8gSW52YWxpZCBxdWVyeVJlbmRlcmVkRmVhdHVyZXMgdHlwaW5nXG4gICAgY29uc3QgcGFyYW1zOiBhbnkgPSB7IGxheWVyczogW3RoaXMubGF5ZXJJZF0gfTtcbiAgICBpZiAoIXRoaXMucG9pbnRUcGwpIHtcbiAgICAgIHBhcmFtcy5maWx0ZXIgPSBbJz09JywgJ2NsdXN0ZXInLCB0cnVlXTtcbiAgICB9XG4gICAgdGhpcy5jbHVzdGVyUG9pbnRzID0gdGhpcy5NYXBTZXJ2aWNlLm1hcEluc3RhbmNlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhwYXJhbXMpO1xuICAgIHRoaXMuQ2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cbn1cbiJdfQ==